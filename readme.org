#+TITLE: chart-svg

[[https://hackage.haskell.org/package/chart-svg][file:https://img.shields.io/hackage/v/chart-svg.svg]] [[https://github.com/tonyday567/chart-svg/actions?query=workflow%3Ahaskell-ci][file:https://github.com/tonyday567/chart-svg/workflows/haskell-ci/badge.svg]]

A charting library targetting SVG.

* Usage

#+begin_src haskell :file other/usage.svg :results output graphics file :exports both
:set -XOverloadedLabels
:set -XOverloadedStrings
import Chart
import Optics.Core
lines = [[Point 0.0 1.0, Point 1.0 1.0, Point 2.0 5.0],[Point 0.0 0.0, Point 2.8 3.0],[Point 0.5 4.0, Point 0.5 0]]
styles = (\c -> defaultLineStyle & #color .~ palette1 c & #size .~ 0.015) <$> [0..2]
cs = zipWith (\s x -> LineChart s [x]) styles lines
lineExample = mempty & #charts .~ named "line" cs & #hudOptions .~ defaultHudOptions :: ChartOptions
writeChartOptions "other/usage.svg" lineExample
#+end_src

#+RESULTS:
[[file:other/usage.svg]]

See the haddock documentation for a detailed overview and [[file:gallery.md][the gallery]] for some potential inspiration.

* ChangeLog
:PROPERTIES:
:EXPORT_FILE_NAME: chart-svg-changelog
:END:

[[file:other/banner.svg]]

** 0.4


0.4 is a plumbing release.

*** Text ==> ByteString

Attoparsec ==> FlatParse
neat-interpolation ==> string-interpolate

text is hardcoded as Text, which has biased design towards Text everywhere. 0.4 includes a move to bytestring with a few library changes:
  - parsing with flatparse (replacing attoparsec). The ergonomics of flatparse is very nice to work with in a Haskell setting, especially with chainr, and easy but restricted template-haskell magic.
  - quasi-quotation is via string-interpolate, (replacing neat-interpolation).

*** lucid ==> Svg

Printing SVG has moved internal to the library, replacing lucid (and blaze-svg under the hood).

Charts now render to Markup, which can be thought of as a restricted subset of XML, with SVG headers and trimmings.

The charts are formed from a very few svg tags and attributes: class, polyline, rect, point, d paths, ellipse, and then style as attributes and text as content.

*** tree-diff

In part, this has been done to introduce https://hackage.haskell.org/package/tree-diff into the machinery. Instead of sending entirely new *.svg's to a web browser, we will be able to send a diff of the raw SVG as a change to a chart. HUD elements becomes much more stable in this setup, and traffic over the websocket reduces by an order or so, resulting in a smoother rendering onscreen. In local tests, FPS can approach 90 or so when zooming on chart detail.

** 0.3

[[https://hackage.haskell.org/package/chart-svg][chart-svg-0.3]] is a major rewrite of a library I've had in the toolkit for a while. This has been a major refactoring and I'd like to share a few highlights.

*** Monomorphic primitives

Chart primitives boil down to a very short list. Charts consist of:

- Rectangles
- Lines
- Glyphs (Geometric Shapes such as circles and arrows)
- Text (specifically positioned on a page) &
- Paths (curves)

The core ~Chart~ type now reflects this and looks like:

#+begin_src haskell
data Chart where
  RectChart :: RectStyle -> [Rect Double] -> Chart
  LineChart :: LineStyle -> [[Point Double]] -> Chart
  GlyphChart :: GlyphStyle -> [Point Double] -> Chart
  TextChart :: TextStyle -> [(Text, Point Double)] -> Chart
  PathChart :: PathStyle -> [PathData Double] -> Chart
  BlankChart :: [Rect Double] -> Chart
  deriving (Eq, Show)

newtype ChartTree = ChartTree {tree :: Tree (Maybe Text, [Chart])} deriving (Eq, Show, Generic)
#+end_src

You can find examples of all of these in Chart.Examples.

Compared to 0.2.3 ...

#+begin_src haskell
data Chart a = Chart
  { -- | annotation style for the data
    annotation :: Annotation,
    -- | list of data elements, either points or rectangles.
    xys :: [XY a]
  }

data Annotation
  = RectA RectStyle
  | TextA TextStyle [Text]
  | GlyphA GlyphStyle
  | LineA LineStyle
  | PathA PathStyle [PathInfo Double]
  | BlankA

data XY a
  = PointXY (Point a)
  | RectXY (Rect a)
#+end_src

... the unification of style via Annotation and data via XY has been ditched, and there is now a simple and tight coupling between style, data type and primitive.

I originally tried for user extensibility of what a Chart was but, in the course of refactoring, the complexity cost started to weigh pretty heavily on the code base. In this particular case, working with a concrete, serializable representation, amenable to optics and pattern matching trumped higher-kinded flexibility.

The new Chart sum type may not cover a useful primitive, or there may be ideas that fall between the GADT definition, but allowing for this just wasn't worth it versus accepting future refactoring costs.

~ChartTree~ is in constrast to the prior usage of a ~[Chart]~ as the basic chart type, and fits in well with the notion of chart as svg, and thus xml tree. The rose-tree bundling and naming of chart components enables easy downstream manipulation with tools like reanimate and CSS.

*** Browser-centric

#+attr_html: :width 400
#+caption: A LineChart
[[file:other/line.svg]]

Existing chart ecosystems, such as excel, [[https://d3js.org/][d3js]] or [[https://github.com/plotly/plotly.js][plotly]], were built in earlier times and don't tend to have regard for modern browser conventions. One addition to the library is to try and fit in with user color scheme preferences. ~Chart-svg~ charts can respect [[https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme][prefers-color-scheme]] and once [[https://github.com/haskell-infra/www.haskell.org/issues/8][this Hackage ticket]] gets done, should look superb in a haddock.


The design flexibility you get from thinking of a chart as primitive shapes to be rendered in a browser also helps expand any definition of what a chart is. A recent example of this can be found in the [[https://hackage.haskell.org/package/dotparse][dotparse]] library which includes production of a [[https://hackage.haskell.org/package/numhask-0.10.1.0][chart]] I added to the numhask docs. Given the constraints of Haddock, the chart is not (yet) clickable, but is clickable in the [[https://hackage.haskell.org/package/numhask-0.10.1.0/docs/other/nh.svg][docs]] ...
This is very difficult to do in other chart libraries outside of direct javascript hacking. Imagine a future where visualisations of class hierarchies help us to tooltip, backlink and navigate complex code bases such as lens.

** Better Colors

#+caption: Default palette experiments from color-adjust
#+attr_html: :width 400
[[file:other/wheel.svg]]

Default colors have been modified with the help of the [[https://bottosson.github.io/posts/oklab/][oklab color space]]. oklab has recently been introduced to the CSS standards and will become important in the coming years. You can read more about the development of this in a [recent]({{< relref "color-adjust" >}}) post, but I'm more than happy with the look and feel improvements you get from better lumination and saturation scaling.

** Future development

#+attr_html: :width 200
#+caption: An example from dotparse
[[file:other/ex.svg]]


[[https://hackage.haskell.org/package/dotparse][Dotparse]] has been a useful test of interoperability, utilising a centuries-old schema and the wonderful new parsing paradigm that is [[https://hackage.haskell.org/package/flatparse][flatparse]], to create a modern web page artifact. If the ideas there are combined with the direction [[https://jonascarpay.com/posts/2022-04-26-calligraphy-tutorial.html][calligraphy]] is taking, we could make clickable visualizations of module, class and call graph heirarchies. That could take performance benchmarking, testing, Haddocks and Hackage to another level, and a unique one compared with other languages.

Some [[https://hackage.haskell.org/package/reanimate][reanimate]] experiments have been carved out of the project in the interests of complexity management, but can still be found in [[https://github.com/tonyday567/chart-reanimate][chart-reanimate]]. ~chart-svg~ handles text well, and the gap between what is a chart and what is text rendering is getting smaller. I'm personally string diagram blind (a rare but real affliction), but animation of string diagrams would look good on the page and be very benficial to documentation.

I'm pretty happy with the recent refactorings and I suspect the integration of visualization with documentation will remain a weird hobby of mine for a good while. The library is nine parts aesthetics and zero parts commercial, but if it ever gets sponsorship it could be an interesting alternative to Excel, d3js and their clones.

Any ideas or criticisms are gratefully appreciated.
* Bugz
** styleBox' imprecision

- SVG is, in general, an additive model eg a border adds a constant amount no matter the scale or aspect. Text charts, in particular, can have small data boxes but large style additions to the box.
- rescaling of style here is, in juxtaposition, a multiplicative model.

In practice, this can lead to weird corner cases and unrequited distortion.

The example below starts with the unit chart, and a simple axis bar, with a dynamic overhang, so that the axis bar represents the x-axis extremity.

#+begin_src haskell :results output
exHud h = defaultHudOptions & set #chartAspect ChartAspect & set #axes [(1,defaultAxisOptions & over #bar (fmap (set #overhang h)) & set (#ticks % #ttick) Nothing & set (#ticks % #gtick) Nothing & set (#ticks % #ltick) Nothing)]
:t exHud
x1 h = addHud (exHud h) t1
:t x1
#+end_src

#+begin_src haskell
view styleBox' $ set styleBox' (Just one) (x1 0.1)
#+end_src

#+RESULTS:
: Just Rect -0.5 0.5 -0.5 0.5001171875000001

#+begin_src haskell
view styleBox' $ set styleBox' (Just one) (x1 0)
#+end_src

#+RESULTS:
: Just Rect -0.500049504950495 0.5000495049504949 -0.5 0.5001171875000001

* Development

#+begin_src haskell :results output
:reload
:set prompt "> "
:set -XOverloadedLabels
:set -XOverloadedStrings
import Chart
import Chart.Examples
import Optics.Core
import FlatParse.Basic
import qualified Data.ByteString as BS
import GHC.Exts
import Data.TreeDiff
import qualified Data.TreeDiff.OMap as O
import qualified Data.Set
#+end_src

#+RESULTS:
: Ok, 15 modules loaded.
: >

** basic ChartOptions ==> Markup ==> ByteString rendering pipeline

#+begin_src haskell
let c0 = ChartOptions (defaultMarkupOptions & #cssOptions % #preferColorScheme .~ PreferNormal) mempty mempty
c0
#+end_src

#+RESULTS:
: ChartOptions {markupOptions = MarkupOptions {markupHeight = 300.0, cssOptions = CssOptions {shapeRendering = NoShapeRendering, preferColorScheme = PreferNormal, cssExtra = ""}}, hudOptions = HudOptions {chartAspect = FixedAspect 1.5, axes = [], frames = [], legends = [], titles = []}, charts = ChartTree {tree = Node {rootLabel = (Nothing,[]), subForest = []}}}

#+begin_src haskell
markupChartOptions c0
#+end_src

#+RESULTS:
: Markup {tag = "svg", atts = Attributes {attMap = fromList [(Attribute "height","300.0"),(Attribute "viewBox","-0.75 -0.5 1.5 1.0"),(Attribute "width","450.0"),(Attribute "xmlns","http://www.w3.org/2000/svg"),(Attribute "xmlns:xlink","http://www.w3.org/1999/xlink")]}, contents = [MarkupLeaf (Markup {tag = "style", atts = Attributes {attMap = fromList []}, contents = [Content ""]}),MarkupLeaf (Markup {tag = "g", atts = Attributes {attMap = fromList [(Class,"chart")]}, contents = []}),MarkupLeaf (Markup {tag = "g", atts = Attributes {attMap = fromList [(Class,"hud")]}, contents = []})]}

#+begin_src haskell
printMarkup $ markupChartOptions c0
#+end_src

#+RESULTS:
: <svg height=\"300.0\" viewBox=\"-0.75 -0.5 1.5 1.0\" width=\"450.0\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><style></style><g class=\"chart\"/><g class=\"hud\"/></svg>

*** checking round trip iso for printMarkup . parseMarkup

#+begin_src haskell
writeAllExamples
#+end_src

#+RESULTS:
: ok

#+begin_src haskell
fileList fp =  fmap (filter (/= ".DS_Store")) (listDirectory fp)
fps <- fileList "other"
fps
#+end_src

#+RESULTS:
| rect.svg | sbar.svg | debug.svg | unit.svg | path.svg | arrow.svg | arcflags.svg | wheel.svg | hudoptions.svg | ellipse.svg | surface.svg | cubic.svg | gradient.svg | text.svg | bar.svg | line.svg | glyphs.svg | venn.svg | quad.svg | ellipse2.svg | usage.svg | wave.svg | date.svg |

 #+begin_src haskell
:{
isoMarkupParse :: BS.ByteString -> Bool
isoMarkupParse x = case runParser markupP x of
  OK l "" -> printMarkup l == x
  _ -> False

isoFile :: FilePath -> IO Bool
isoFile fp = do
  bs <- BS.readFile fp
  pure $ isoMarkupParse bs
:}

 #+end_src

#+RESULTS:
: ghci| ghci| ghci| ghci| ghci| ghci| ghci| ghci| ghci| ghci|


#+begin_src haskell
fok <- mapM isoFile (("other/"<>) <$> fps)
zip fps fok
#+end_src

#+RESULTS:
| rect.svg       | True |
| sbar.svg       | True |
| debug.svg      | True |
| unit.svg       | True |
| path.svg       | True |
| arrow.svg      | True |
| arcflags.svg   | True |
| wheel.svg      | True |
| hudoptions.svg | True |
| ellipse.svg    | True |
| surface.svg    | True |
| cubic.svg      | True |
| gradient.svg   | True |
| text.svg       | True |
| bar.svg        | True |
| line.svg       | True |
| glyphs.svg     | True |
| venn.svg       | True |
| quad.svg       | True |
| ellipse2.svg   | True |
| usage.svg      | True |
| wave.svg       | True |
| date.svg       | True |

** tree-diff patch development

patch is in the test suite, so:

#+begin_src elisp
(setq haskell-process-args-cabal-repl '("chart-svg:test"))
#+end_src

#+RESULTS:
| chart-svg:test |

#+begin_src haskell
:set prompt "> "
:t printPatchExamples
#+end_src

#+RESULTS:
: printPatchExamples :: IO ()

** patch examples

#+begin_src haskell :results output
printPatchExamples
#+end_src

#+RESULTS:
#+begin_example
"class change"
Markup {
  atts = Attributes
    (Map.fromList [_×_ -"a" +"b"])}
"delete an attribute"
Markup {
  atts = Attributes
    (Map.fromList
      [-_×_ (Attribute "b") "c"])}
"insert an attribute"
Markup {
  atts = Attributes
    (Map.fromList
      [+_×_ (Attribute "d") "e"])}
"change a tag"
Markup {tag = -"top" +"newtop"}
"change a markup leaf"
Markup {
  contents = [
    MarkupLeaf
      Markup {
        tag = -"leaf" +"newleaf"}]}
"delete a leaf"
Markup {
  contents = [
    -MarkupLeaf
      Markup {
        tag = "leaf",
        atts = Attributes
          (Map.fromList []),
        contents = []}]}
"insert a leaf"
Markup {
  contents = [
    +MarkupLeaf
      Markup {
        tag = "newleaf",
        atts = Attributes
          (Map.fromList []),
        contents = []}]}
"insert attribute"
Markup {
  contents = [
    MarkupLeaf
      Markup {
        atts = Attributes
          (Map.fromList
            [
              +_×_ Class "a",
              +_×_ (Attribute "b") "c"])}]}
"modify content"
Markup {
  contents = [
    Content
      -"text"
      +"textual content"]}
"deep leaf insertion"
Markup {
  contents = [
    MarkupLeaf
      Markup {
        contents = [
          +MarkupLeaf
            Markup {
              tag = "newdeepleaf",
              atts = Attributes
                (Map.fromList []),
              contents = [
                Content "deeper content"]}]},
    Content
      -"text"
      +"textual content"]}
#+end_example

** ToDo creating a proper tree-diff patch

To be a real patch:

- count tree levels for changes
- count insertion, deletion index for lists, and store record name for recs
- invent javascript actions for identified changes

#+begin_src haskell
let diff1 = ediff m0 m1
#+end_src

#+RESULTS:

#+begin_src haskell
diff1
#+end_src

#+RESULTS:
: Cpy (EditRec "Markup" (fromList [("tag",Cpy (EditExp (App "\"top\"" []))),("atts",Cpy (EditApp "Attributes" [Cpy (EditApp "Map.fromList" [Cpy (EditLst [Cpy (EditApp "_\215_" [Cpy (EditExp (App "Class" [])),Swp (EditExp (App "\"a\"" [])) (EditExp (App "\"b\"" []))]),Cpy (EditExp (App "_\215_" [App "Attribute" [App "\"b\"" []],App "\"2\"" []]))])])])),("contents",Cpy (EditExp (Lst [App "MarkupLeaf" [Rec "Markup" (fromList [("tag",App "\"g\"" []),("atts",App "Attributes" [App "Map.fromList" [Lst []]]),("contents",Lst [])])],App "Content" [App "\"text\"" []]])))]))

#+begin_src haskell
fmap prettyEditExpr $ filterChangedEdit diff1
#+end_src

#+RESULTS:
: Just Markup {atts = Attributes (Map.fromList [_×_ -"a" +"b"])}

#+begin_src haskell
prettyEditExpr diff1
#+end_src

#+RESULTS:
#+begin_example
Markup {
  tag = "top",
  atts =
  Attributes
    (Map.fromList [_×_ Class -"a" +"b", _×_ (Attribute "b") "2"]),
  contents =
  [ MarkupLeaf
      Markup {
        tag = "g", atts = Attributes (Map.fromList []), contents = []},
    Content "text"]}
#+end_example

